<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ZKsync OS Server Developer Docs</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="css/version-box.css">
        <link rel="stylesheet" href="./css/mdbook-admonish.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ZKsync OS Server Developer Docs</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/matter-labs/zksync-os-server/tree/main/docs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="zksync-os-server-developer-documentation"><a class="header" href="#zksync-os-server-developer-documentation">ZKsync OS Server Developer Documentation</a></h1>
<p>This book guides you through running, understanding, and extending the <strong>ZKsync OS Server</strong>.</p>
<h2 id="understanding-the-system"><a class="header" href="#understanding-the-system">Understanding the System</a></h2>
<p>Deep dives into internal components and lifecycle.</p>
<ul>
<li><a href="design/db.html">Database Layout</a></li>
<li><a href="design/state.html">State Model</a></li>
<li><a href="design/tree.html">Merkle Tree Structure</a></li>
<li><a href="design/genesis.html">Genesis Process</a></li>
</ul>
<h2 id="running-the-system"><a class="header" href="#running-the-system">Running the System</a></h2>
<p>These guides help you set up and operate the server in different environments.</p>
<ul>
<li><a href="guides/running_with_l1.html">Run against Layer 1 (L1)</a> ‚Äî Local dev chain and Sepolia testnet setup, environment variables, common pitfalls.</li>
<li><a href="guides/updating.html">Updating Contracts</a> ‚Äî Rebuilding and deploying custom contracts, migration flow, testing.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setup"><a class="header" href="#setup">Setup</a></h1>
<ul>
<li><a href="setup/prerequisites.html">Prerequisites</a></li>
<li><a href="setup/local_run.html">Local Run</a></li>
<li><a href="setup/docker.html">Docker Setup</a></li>
<li><a href="setup/external_node.html">External Node</a></li>
<li><a href="setup/local_explorer.html">Otterscan (Local Explorer)</a></li>
<li><a href="setup/exposed_ports.html">Exposed Ports</a></li>
<li><a href="setup/faq.html">FAQ</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>This project requires:</p>
<ul>
<li>The <strong>Foundry nightly toolchain</strong></li>
<li>The <strong>Rust toolchain</strong></li>
</ul>
<h3 id="install-foundry-v134"><a class="header" href="#install-foundry-v134">Install Foundry (v1.3.4)</a></h3>
<p>Install <a href="https://getfoundry.sh/">Foundry</a> v1.3.4 (newer <strong>stable</strong> versions are likely to work too but not guaranteed):</p>
<pre><code class="language-bash"># Download the Foundry installer
curl -L https://foundry.paradigm.xyz | bash

# Install forge, cast, anvil, chisel
# Ensure you are using the 1.3.4 stable release
foundryup -i 1.3.4
</code></pre>
<p>Verify your installation:</p>
<pre><code class="language-bash">anvil --version
</code></pre>
<p>The output should include a <code>anvil Version: 1.3.4-v1.3.4</code>.</p>
<h3 id="install-rust"><a class="header" href="#install-rust">Install Rust</a></h3>
<p>Install <a href="https://www.rust-lang.org/tools/install">Rust</a> using <code>rustup</code>:</p>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<p>After installation, ensure Rust is available:</p>
<pre><code class="language-bash">rustc --version
</code></pre>
<h3 id="linux-packages"><a class="header" href="#linux-packages">Linux packages</a></h3>
<pre><code class="language-bash"># essentials
sudo apt-get install -y build-essential pkg-config cmake clang lldb lld libssl-dev apt-transport-https ca-certificates curl software-properties-common git    
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="run"><a class="header" href="#run">Run</a></h2>
<h3 id="local"><a class="header" href="#local">Local</a></h3>
<p>To run node locally, first launch <code>anvil</code>:</p>
<pre><code>anvil --load-state zkos-l1-state.json --port 8545
</code></pre>
<p>then launch the server:</p>
<pre><code>cargo run
</code></pre>
<p>To restart the chain, erase the local DB and re-run anvil:</p>
<pre><code>rm -rf db/*
</code></pre>
<p>By default, fake (dummy) proofs are used both for FRI and SNARK proofs.</p>
<p><strong>Rich account:</strong></p>
<pre><code>PRIVATE_KEY = 0x7726827caac94a7f9e1b160f7ea819f172f7b6f9d2a97f992c38edeab82d4110
ACCOUNT_ID = 0x36615Cf349d7F6344891B1e7CA7C72883F5dc049
</code></pre>
<p>Example transaction to send:</p>
<pre><code>cast send -r http://localhost:3050 0x5A67EE02274D9Ec050d412b96fE810Be4D71e7A0 --value 
100 --private-key 0x7726827caac94a7f9e1b160f7ea819f172f7b6f9d2a97f992c38edeab82d4110
</code></pre>
<p><strong>Config options</strong></p>
<p>See <code>node/sequencer/config.rs</code> for config options and defaults. Use env variables to override, e.g.:</p>
<pre><code>prover_api_fake_provers_enabled=false cargo run --release
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docker"><a class="header" href="#docker">Docker</a></h1>
<pre><code>sudo docker build -t zksync_os_sequencer .
sudo docker run -d --name sequencer -p 3050:3050 -p 3124:3124 -p 3312:3312 -e batcher_maximum_in_flight_blocks=15  -v /mnt/localssd/db:/db   zksync_os_sequencer
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="external-node"><a class="header" href="#external-node">External node</a></h1>
<p>Setting the <code>block_replay_download_address</code> environment variable puts the node in external node mode, which means it
receives block replays from another node instead of producing its own blocks. The node will get priority transactions
from L1 and check that they match the ones in the replay but it won‚Äôt change L1 state.</p>
<p>To run the external node locally, you need to set its services‚Äô ports so they don‚Äôt overlap with the main node.</p>
<p>For example:</p>
<pre><code class="language-bash">block_replay_download_address=localhost:3053 \
block_replay_server_address=0.0.0.0:3054 \
sequencer_rocks_db_path=./db/en sequencer_prometheus_port=3313 rpc_address=0.0.0.0:3051 \
cargo run --release
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="otterscan-local-explorer"><a class="header" href="#otterscan-local-explorer">Otterscan (Local Explorer)</a></h1>
<p>Server supports <code>ots_</code> namespace and hence can be used in combination
with <a href="https://github.com/otterscan/otterscan">Otterscan</a>
block explorer. To run a local instance as a Docker container (bound to <code>http://localhost:5100</code>):</p>
<pre><code>docker run --rm -p 5100:80 --name otterscan -d --env ERIGON_URL="http://127.0.0.1:3050" otterscan/otterscan
</code></pre>
<p>See Otterscan‚Äôs <a href="https://docs.otterscan.io/intro/">docs</a> for other running options.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exposed-ports"><a class="header" href="#exposed-ports">Exposed Ports</a></h1>
<ul>
<li><code>3050</code> - L2 JSON RPC</li>
<li><code>3053</code> - Block replay server (transport for EN)</li>
<li><code>3124</code> - Prover API (e.g. <code>127.0.0.1/prover-jobs/status</code>) (only enabled if <code>prover_api_component_enabled</code> is set to
<code>true</code>)</li>
<li><code>3312</code> - Prometheus</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<p><strong>Failed to read L1 state: contract call to <code>getAllZKChainChainIDs</code> returned no data (‚Äú0x‚Äù); the called address might
not be a contract</strong></p>
<p>Something went wrong with L1 - check that you‚Äôre really running the anvil with the proper state on the right port.</p>
<p><strong>Failed to deserialize context</strong></p>
<p>If you hit this error when starting, check if you don‚Äôt have some ‚Äòold‚Äô rocksDB data in db/node1 directory.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design-principles"><a class="header" href="#design-principles">Design principles</a></h1>
<ul>
<li>Minimal, async persistence
<ul>
<li>to meet throughput and latency requirements, we avoid synchronous persistence at the critical path. Additionally,
we aim at storing only the data that is strictly needed - minimizing the potential for state inconsistency</li>
</ul>
</li>
<li>Easy to replay arbitrary blocks
<ul>
<li>Sequencer: components are idempotent</li>
<li>Batcher: <code>batcher</code> component skips all blocks until the first uncommitted batch.
Thus, downstream components only receive batches that they need to act upon</li>
</ul>
</li>
<li>State - strong separation between
<ul>
<li>Actual state - data needed to execute VM: key-value storage and preimages map</li>
<li>Receipts repositories - data only needed in API</li>
<li>Data related to Proofs and L1 - not needed by sequencer / JSON RPC - only introduced downstream from <code>batcher</code></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subsystems"><a class="header" href="#subsystems">Subsystems</a></h1>
<ul>
<li><strong>Sequencer</strong> subsystem ‚Äî mandatory for every node. Executes transactions in VM, sends results downstream to other
components.
<ul>
<li>Handles <code>Produce</code> and <code>Replay</code> commands in an uniform way (see <code>model/mod.rs</code> and <code>execution/block_executor.rs</code>)</li>
<li>For each block: (1) persists it in WAL (see <code>block_replay_storage.rs</code>), (2) pushes to <code>state</code> (see <code>state</code>
crate), (3) exposes the block and tx receipts to API (see <code>repositories/mod.rs</code>), (4) pushes to async channels for
downstream subsystems. Waits on backpressure.</li>
</ul>
</li>
<li><strong>API</strong> subsystem ‚Äî optional (not configurable atm). Has shared access to <code>state</code>. Exposes ethereum-compatible JSON
RPC</li>
<li><strong>Batcher</strong> subsystem ‚Äî runs for the main node - most of it is disabled for ENs.
<ul>
<li>Turns a stream of blocks into a stream of batches (1 batch = 1 proof = 1 L1 commit); exposes Prover APIs; submits
batches and proofs to L1.</li>
<li>For each batch, computes the Prover Input (runs RiscV binary (<code>app.bin</code>) and records its input as a stream of
<code>Vec&lt;u32&gt;</code> - see <code>batcher/mod.rs</code>)</li>
<li>This process requires Merkle Tree with materialized root hashes and proofs at every block boundary.</li>
<li>Runs L1 senders for each of <code>commit</code> / <code>prove</code> / <code>execute</code></li>
<li>Runs Priority Tree Manager that applies new L1-&gt;L2 transactions to the dynamic Merkle tree and prepares <code>execute</code> commands.
It‚Äôs run both for main node and ENs. ENs don‚Äôt send <code>execute</code> txs to L1, but they need to keep the tree up to date,
so that if the node become main, it doesn‚Äôt need to build the tree from scratch.</li>
</ul>
</li>
</ul>
<p>Note on <strong>Persistent Tree</strong> ‚Äî it is only necessary for Batcher Subsystem. Sequencer doesn‚Äôt need the tree ‚Äî block hashes
don‚Äôt include root hash. Still, even when batcher subsystem is not enabled, we want to run the tree for potential
failover.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="component-details"><a class="header" href="#component-details">Component Details</a></h1>
<img width="1549" height="658" alt="Screenshot 2025-07-24 at 15 00 55" src="https://github.com/user-attachments/assets/e1a472bd-d14b-4840-bd89-223347bebccf" />
<p>See individual components and state recovery details in the table below. Note that most components have little to no
internal state or persistence ‚Äî this is one of the design principles.</p>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>In-memory state</th><th>Persistence</th><th>State Recovery</th></tr></thead><tbody>
<tr><td><strong>Command Source</strong></td><td><code>starting_block</code> (only used on startup)</td><td>none</td><td><code>starting_block</code> is the first block <strong>after</strong> the compacted block stored in <code>state</code>, i.e., <code>starting_block = highest_block - blocks_to_retain_in_memory</code>.</td></tr>
<tr><td><strong>BlockContextProvider</strong></td><td><code>next_l1_priority_id</code>; <code>block_hashes_for_next_block</code> (last 256 block hashes)</td><td>none</td><td><code>next_l1_priority_id</code>: take from <code>ReplayRecord</code> of <code>starting_block - 1</code>; <code>block_hashes_for_next_block</code>: take from 256 <code>ReplayRecord</code>s before <code>starting_block</code></td></tr>
<tr><td><strong>L1Watcher</strong></td><td>Gapless list of Priority transactions - starting from the last committed to L1</td><td>none</td><td>none - recovers itself from L1</td></tr>
<tr><td><strong>L2Mempool</strong> <em>(RETH crate)</em></td><td>prepared list of pending L2 transactions</td><td>none</td><td>none (consider persisting mempool transactions in the future)</td></tr>
<tr><td><strong>BlockExecutor</strong></td><td>none üî•</td><td>none</td><td>none</td></tr>
<tr><td><strong>Repositories</strong> (API subsystem)</td><td>BlockHeaders and Transactions for ~<code>blocks_to_retain_in_memory</code> blocks</td><td>Historical BlockHeaders and Transactions</td><td>none - recovers naturally when replaying blocks from <code>starting_block</code></td></tr>
<tr><td><strong>State</strong></td><td>All Storage Logs and Preimages for <code>blocks_to_retain_in_memory</code> last blocks</td><td>Compacted state at some older block (<code>highest_block - blocks_to_retain_in_memory</code>): full state map and all preimages</td><td>none - recovers naturally when replaying blocks from <code>starting_block</code></td></tr>
<tr><td><strong>Merkle Tree</strong></td><td>Only persistence</td><td>Full Merkle tree - including previous values on each leaf</td><td>none</td></tr>
<tr><td>‚¨áÔ∏è <em>Batcher Subsystem Components</em></td><td>‚¨áÔ∏è <em>Components below operate on Batches - not BlocksÔ∏è</em></td><td>‚¨áÔ∏è <em>Components below must not rely on persistence - otherwise failover is not possible</em></td><td>‚¨áÔ∏è</td></tr>
<tr><td><strong>Batcher</strong></td><td>startup: <code>starting_batch</code> and <code>batcher_starting_block</code>; <br/> operation: Trailing Batch‚Äôs <code>CommitBatchInfo</code>;</td><td>none</td><td><code>first_block_to_process</code>: block <strong>after</strong> the last block in the last committed L1 batch;<br/> <code>last_persisted_block</code>: the block after which we start checking for batch timeouts <br/> <code>StoredBatchInfo</code> in <code>run_loop</code>: Currently: from FRI cache; todo - Load last committed <code>StoredBatchInfo</code> from L1 OR reprocess last committed batch</td></tr>
<tr><td><strong>Prover Input Generator</strong></td><td></td><td>none</td><td>none</td></tr>
<tr><td><strong>FRI Job Manager</strong></td><td>Gapless List of unproved batches with <code>ProverInput</code> and prover assignment info</td><td>none</td><td>none - batches before <code>starting_batch</code> are guaranteed to have FRI proofs, batches after will go through the pipeline again</td></tr>
<tr><td><strong>FRI Store/Cache</strong></td><td>none</td><td><code>Map&lt;BatchNumber, FRIProof&gt;</code> (todo: extract from the node process to enable failover)</td><td>none</td></tr>
<tr><td><strong>L1 Committer</strong></td><td>none*</td><td>none</td><td>none - recovers itself from L1</td></tr>
<tr><td><strong>L1 Proof Submitter</strong></td><td>none*</td><td>none</td><td>none - recovers itself from L1</td></tr>
<tr><td><strong>L1 Executor</strong></td><td>none*</td><td>none</td><td>none - recovers itself from L1</td></tr>
<tr><td><strong>SNARK Job Manager</strong> (TODO - missing)</td><td>Gapless list of batches with their FRI proofs and prover assignment info</td><td>none</td><td>Load batches that are committed but not proved on L1 yet. Load their FRI proofs from FRI cache (TODO)</td></tr>
<tr><td><strong>Priority Tree Manager</strong></td><td>Dynamic Merkle tree with L1-&gt;L2 transaction hashes</td><td>Compressed data needed to rebuild the tree, see <code>CachedTreeData</code> for more details</td><td>none - recovers itself from replay storage</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="rpc"><a class="header" href="#rpc">RPC</a></h1>
<ul>
<li>All standard <code>eth_</code> methods are supported (except those specific to EIP-2930, EIP-4844 and EIP-7702). Block tags have
a special meaning:
<ul>
<li><code>earliest</code> - not supported yet (will return genesis or first uncompressed block)</li>
<li><code>pending</code> - the latest produced block</li>
<li><code>latest</code> - same as <code>pending</code> (consider taking consensus into account here)</li>
<li><code>safe</code> - the latest block that has been committed to L1</li>
<li><code>finalized</code> - not supported yet (will return the latest block that has been executed on L1)</li>
</ul>
</li>
<li><code>zks_</code> namespace is kept to the minimum right now to avoid legacy from Era. Only following methods are supported:
<ul>
<li><code>zks_getBridgehubContract</code></li>
</ul>
</li>
<li><code>ots_</code> namespace is used for Otterscan integration (meant for local development only)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prover-api"><a class="header" href="#prover-api">Prover API</a></h1>
<pre><code>        .route("/prover-jobs/status", get(status))
        .route("/prover-jobs/FRI/pick", post(pick_fri_job))
        .route("/prover-jobs/FRI/submit", post(submit_fri_proof))
        .route("/prover-jobs/SNARK/pick", post(pick_snark_job))
        .route("/prover-jobs/SNARK/submit", post(submit_snark_proof))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="database-schema-overview"><a class="header" href="#database-schema-overview">Database Schema Overview</a></h1>
<p>All persistent data is stored across multiple RocksDB databases:</p>
<ul>
<li>block_replay_wal</li>
<li>preimages</li>
<li>repository</li>
<li>state</li>
<li>tree</li>
<li>proofs (JSON files, not RocksDB)</li>
</ul>
<hr />
<h2 id="1-block_replay_wal"><a class="header" href="#1-block_replay_wal">1. block_replay_wal</a></h2>
<p>Write-ahead log containing recent (non-compacted) block data.</p>
<div class="table-wrapper"><table><thead><tr><th>Column</th><th>Key</th><th>Value</th></tr></thead><tbody>
<tr><td>block_output_hash</td><td>block number</td><td>Block output hash</td></tr>
<tr><td>context</td><td>block number</td><td>Binary-encoded BlockContext (BlockMetadataFromOracle)</td></tr>
<tr><td>last_processed_l1_tx_id</td><td>block number</td><td>ID (u64) of the last processed L1 tx in the block</td></tr>
<tr><td>txs</td><td>block number</td><td>Vector of EIP-2718 encoded transactions</td></tr>
<tr><td>node_version</td><td>block number</td><td>Node version that produced the block</td></tr>
<tr><td>latest</td><td>‚Äòlatest_block‚Äô</td><td>Latest block number</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="2-preimages"><a class="header" href="#2-preimages">2. preimages</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Column</th><th>Key</th><th>Value</th></tr></thead><tbody>
<tr><td>meta</td><td>‚Äòblock‚Äô</td><td>Latest block ID</td></tr>
<tr><td>storage</td><td>hash</td><td>Preimage for the hash</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="3-repository"><a class="header" href="#3-repository">3. repository</a></h2>
<p>Canonical blocks and transactions.</p>
<div class="table-wrapper"><table><thead><tr><th>Column</th><th>Key</th><th>Value</th></tr></thead><tbody>
<tr><td>initiator_and_nonce_to_hash</td><td>address (20 bytes) + nonce (u64)</td><td>Transaction hash</td></tr>
<tr><td>tx_meta</td><td>transaction hash</td><td>Binary TxMeta (hash, number, gas used, etc.)</td></tr>
<tr><td>block_data</td><td>block hash</td><td>Alloy-serialized block</td></tr>
<tr><td>tx_receipt</td><td>transaction hash</td><td>Binary EIP-2718 receipt</td></tr>
<tr><td>meta</td><td>‚Äòblock_number‚Äô</td><td>Latest block number</td></tr>
<tr><td>tx</td><td>transaction hash</td><td>EIP-2718 encoded bytes</td></tr>
<tr><td>block_number_to_hash</td><td>block number</td><td>Block hash</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="4-state"><a class="header" href="#4-state">4. state</a></h2>
<p>Data compacted from the write-ahead log.</p>
<div class="table-wrapper"><table><thead><tr><th>Column</th><th>Key</th><th>Value</th></tr></thead><tbody>
<tr><td>meta</td><td>‚Äòbase_block‚Äô</td><td>Base block number for this state snapshot</td></tr>
<tr><td>storage</td><td>key</td><td>Value (compacted storage)</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="5-tree"><a class="header" href="#5-tree">5. tree</a></h2>
<p>Merkle-like structure.</p>
<div class="table-wrapper"><table><thead><tr><th>Column</th><th>Key</th><th>Value</th></tr></thead><tbody>
<tr><td>default</td><td>composite (version + nibble + index)</td><td>Serialized Leaf or Internal node</td></tr>
<tr><td>key_indices</td><td>hash</td><td>Key index</td></tr>
</tbody></table>
</div>
<p>Note: The ‚Äòdefault‚Äô column also stores a serialized Manifest at key ‚Äò0‚Äô.</p>
<hr />
<h2 id="6-proofs"><a class="header" href="#6-proofs">6. proofs</a></h2>
<p>Stored as JSON files in a separate directory:
../shared/fri_batch_envelopes</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="state"><a class="header" href="#state">State</a></h1>
<p>The global state is a set of key/value pairs:</p>
<ul>
<li>key = keccak(address, slot)</li>
<li>value = a single 32-byte word (U256)</li>
</ul>
<p>All such pairs are stored (committed) in the Merkle tree (see tree.md).</p>
<h2 id="account-metadata-accountproperties"><a class="header" href="#account-metadata-accountproperties">Account metadata (AccountProperties)</a></h2>
<p>Account-related data (balance, nonce, deployed bytecode hash, etc.) is grouped into an AccountProperties struct. We do NOT store every field directly in the tree. Instead:</p>
<ul>
<li>We hash the AccountProperties struct.</li>
<li>That hash (a single U256) is what appears in the Merkle tree.</li>
<li>The full struct is retrievable from a separate preimage store.</li>
</ul>
<h2 id="special-address-account_storage-0x8003"><a class="header" href="#special-address-account_storage-0x8003">Special address: ACCOUNT_STORAGE (0x8003)</a></h2>
<p>We reserve the synthetic address 0x8003 to map account addresses to their AccountProperties hash. Concretely:
value at key = keccak(0x8003, user_address) = hash(AccountProperties(user_address))</p>
<h2 id="example-fetching-the-nonce-for-address-0x1234"><a class="header" href="#example-fetching-the-nonce-for-address-0x1234">Example: fetching the nonce for address 0x1234</a></h2>
<ol>
<li>Compute key = keccak(0x8003, 0x1234)</li>
<li>Read the U256 value H from the Merkle tree at that key</li>
<li>Look up preimage(H) to get AccountProperties</li>
<li>Take the nonce field from that struct</li>
</ol>
<p>This indirection:</p>
<ul>
<li>Keeps the Merkle tree smaller (one leaf per account metadata bundle)</li>
<li>Avoids multiple leaf updates when several account fields change at once.</li>
</ul>
<h2 id="bytecodes"><a class="header" href="#bytecodes">Bytecodes</a></h2>
<p>We track two related things:</p>
<ol>
<li>What the outside world sees (the deployed / observable bytecode).</li>
<li>An internal, enriched form that adds execution helpers (artifacts).</li>
</ol>
<h3 id="terminology"><a class="header" href="#terminology">Terminology</a></h3>
<ul>
<li>Observable (deployed) bytecode:
The exact bytes you get from an RPC call like eth_getCode or cast code.</li>
<li>Observable bytecode hash (observable_bytecode_hash):
keccak256(observable bytecode). This matches Ethereum conventions.</li>
<li>Internal extended representation:
observable bytecode
<ul>
<li>padding (if any, e.g. to align)</li>
<li>artifacts (pre‚Äëcomputed data used to speed execution, e.g. jumpdest map).</li>
</ul>
</li>
<li>Internal bytecode hash (bytecode_hash):
blake2 hash of the full extended representation above. The extended blob itself lives in the preimage store; only the blake hash is stored in AccountProperties.</li>
</ul>
<h3 id="stored-fields-in-accountproperties"><a class="header" href="#stored-fields-in-accountproperties">Stored fields in AccountProperties</a></h3>
<ul>
<li>bytecode_hash (Bytes32):
blake2 hash of <code>[observable bytecode | padding | artifacts]</code>.</li>
<li>unpadded_code_len (u32):
Length (in bytes) of the original observable bytecode, before any internal padding or artifacts.</li>
<li>artifacts_len (u32):
Length (in bytes) of the artifacts segment appended after padding.</li>
<li>observable_bytecode_hash (Bytes32):
keccak256 of the observable (deployed) bytecode.</li>
<li>observable_bytecode_len (u32):
Length of the observable (deployed) bytecode. (Currently mirrors unpadded_code_len; kept explicitly for clarity / future evolution.)</li>
</ul>
<h3 id="why-two-hashes"><a class="header" href="#why-two-hashes">Why two hashes?</a></h3>
<ul>
<li>keccak (observable_bytecode_hash) is what external tooling expects and can independently recompute.</li>
<li>blake (bytecode_hash) commits to the richer internal representation the node actually executes against (including acceleration data), avoiding recomputing artifacts on every access.</li>
</ul>
<h3 id="lookup-workflow-simplified"><a class="header" href="#lookup-workflow-simplified">Lookup workflow (simplified)</a></h3>
<ol>
<li>From AccountProperties get:
<ul>
<li>bytecode_hash ‚Üí fetch extended blob via preimage store.</li>
<li>observable_bytecode_hash ‚Üí verify against externally visible code if needed.</li>
</ul>
</li>
<li>Use lengths (unpadded_code_len, artifacts_len) to slice:
[0 .. unpadded_code_len) ‚Üí observable code
[end of padding .. end) ‚Üí artifacts</li>
</ol>
<p>This separation keeps the Merkle tree lean while enabling fast execution.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tree"><a class="header" href="#tree">Tree</a></h1>
<p>State is stored in a binary Merkle‚Äëlike tree. In production the logical tree depth is 64 (root at depth 0, leaves at depth 63). We use Blake2 as a tree hashing algorithm.</p>
<p>Optimization:</p>
<ul>
<li>Instead of persisting every individual leaf, we group (package) 8 consecutive leaves together.</li>
<li>8 leaves form a perfectly balanced subtree of height 3 (because 2^3 = 8).</li>
<li>One such packaged subtree is stored as a single DB record.</li>
</ul>
<p>Terminology:</p>
<ul>
<li>We call each 3-level chunk of the logical tree a nibble (note: this is an internal term here).</li>
<li>Effective path length (number of nibbles) = ceil(64 / 3) = 22.</li>
</ul>
<p>So:</p>
<ul>
<li>Logical depth: 64 levels.</li>
<li>Physical traversal steps: 22 nibbles.</li>
<li>Each nibble lookup loads or updates one packaged subtree (8 leaves).</li>
</ul>
<p>Result: fewer DB reads/writes while preserving a logical depth of 64.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="genesis-and-block-0"><a class="header" href="#genesis-and-block-0">Genesis and Block 0</a></h1>
<p>Genesis is the one-time process of starting a new chain and producing its first block.</p>
<h2 id="what-happens-at-genesis"><a class="header" href="#what-happens-at-genesis">What happens at genesis</a></h2>
<ol>
<li>The sequencer starts with an empty database.</li>
<li>It loads a hardcoded file (genesis.json) that defines the initial on-chain state.</li>
<li>This file deploys exactly three system contracts:
<ul>
<li>GenesisUpgrade</li>
<li>L2WrappedBase</li>
<li>ForceDeployer</li>
</ul>
</li>
<li>After loading these, the sequencer begins listening to L1 events that describe the first actual L2 block:
<ul>
<li>Bytecodes to deploy additional contracts (ForceDeployer enables this)</li>
<li>Parameters passed to GenesisUpgrade to finish remaining initialization steps</li>
</ul>
</li>
</ol>
<h2 id="why-these-contracts-exist"><a class="header" href="#why-these-contracts-exist">Why these contracts exist</a></h2>
<ul>
<li>ForceDeployer: Allows forced deployment of predefined contract bytecode needed at boot.</li>
<li>GenesisUpgrade: Finalizes system configuration after initial contract deployment.</li>
<li>L2WrappedBase: Provides a required base implementation (infrastructure dependency).</li>
</ul>
<h2 id="security-perspective"><a class="header" href="#security-perspective">Security perspective</a></h2>
<p>L1 already knows the exact expected initial L2 state (the three contracts and their storage layout).<br />
This state is defined in zksync-era‚Äôs genesis.json and is consumed by the zkStack tooling when setting up the ecosystem on L1.<br />
Because L1 has this canonical reference, it can validate that the L2 started correctly.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Genesis = load predefined state from genesis.json -&gt; deploy 3 core contracts -&gt; process L1 events to finalize initialization -&gt; produce block 0.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guides"><a class="header" href="#guides">Guides</a></h1>
<ul>
<li><a href="guides/running_with_l1.html">Run against Layer 1 (L1)</a></li>
<li><a href="guides/updating.html">Updating Contracts</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-with-l1"><a class="header" href="#running-with-l1">Running with L1</a></h1>
<h2 id="simplest-no-contract-changes-etc"><a class="header" href="#simplest-no-contract-changes-etc">Simplest (no contract changes etc)</a></h2>
<p>If you‚Äôre not doing any contract changes, and simply want to hook up to L1, start anvil with pre-created state.</p>
<p>This repo includes a pre-setup L1 state <code>zkos-l1-state.json</code> that can be loaded into <code>anvil</code>. The state was generated by <code>zkstack init</code> and essentially consists of all L1 contracts deployed and initialized with L2 genesis.
The state comes with some L1 priority transactions that were generated by the old genesis logic and are hence failing in the new implementation.
It also comes with a deposit transaction that makes <code>0x36615cf349d7f6344891b1e7ca7c72883f5dc049</code> into a rich account (&gt;10k ETH) (to regenerate it, see ‚ÄúRegenerate zkos-l1-state.json` below)</p>
<p>Before you run an L1 node, make sure you have a 1.x version of <code>anvil</code> installed (see <a href="https://getfoundry.sh/">foundry guide</a>). Then:</p>
<pre><code>anvil --load-state zkos-l1-state.json --port 8545
...
Listening on 127.0.0.1:8545
...
</code></pre>
<h2 id="advanced-contract-changes-multi-setup--etc"><a class="header" href="#advanced-contract-changes-multi-setup--etc">Advanced (contract changes, multi setup  etc)</a></h2>
<p>If you want to have more custom setup (for example you did some changes in L1 contracts, or want to run multiple sequencers hooked up to the same L1).</p>
<p>The high level steps are:</p>
<ul>
<li>Start L1 (anvil)</li>
<li>setup ecosystem and configs using zkstack cli from zksync-era</li>
<li>update necessary config</li>
<li>start sequencers</li>
</ul>
<h3 id="start-l1"><a class="header" href="#start-l1">Start L1</a></h3>
<p>Start local L1 ‚Äì by running <code>anvil</code>.</p>
<h3 id="setup-ecosystem-and-chain-configs"><a class="header" href="#setup-ecosystem-and-chain-configs">Setup ecosystem and chain configs</a></h3>
<p>Use <code>zksync-os-integration</code> branch from<code>zksync-era</code>.</p>
<p>IMPORTANT: the contracts deployed will come from the zksync-era/contracts directory. So if you want to test any changes to contracts, you have to put them there.</p>
<p>Make sure that your zkstack was compiled from ‚Äòmain‚Äô branch of era, and is relatively fresh (after September 10).</p>
<p>Run this from the directory <strong>above</strong> zksync-era.</p>
<pre><code>mkdir zkstack-playground &amp;&amp; cd zkstack-playground
zkstack ecosystem create --ecosystem-name local-v1 --l1-network localhost --chain-name era1 --chain-id 270 --prover-mode no-proofs --wallet-creation random --link-to-code ../../zksync-era --l1-batch-commit-data-generator-mode rollup --start-containers false   --base-token-address 0x0000000000000000000000000000000000000001 --base-token-price-nominator 1 --base-token-price-denominator 1 --evm-emulator false
</code></pre>
<p>For validium, use <code>--l1-batch-commit-data-generator-mode validium</code> instead.</p>
<p>This will create a ‚Äòlocal-v1‚Äô ecosystem directory, with one chain ‚Äòera1‚Äô.</p>
<h3 id="fund-l1-accounts"><a class="header" href="#fund-l1-accounts">Fund L1 accounts</a></h3>
<p>Now we‚Äôre ready to compile contracts and deploy them to L1.</p>
<p>Before the step below, you might want to fund some of the wallet accounts above.
If you‚Äôre running on local L1, you can use the script below. Do not forget to use different PRIVKEY in case you have initialized the anvil with a different mnemonic.
If you‚Äôre running on sepolia, zkstack will tell you which accounts to fund.</p>
<pre><code class="language-shell">RPC_URL=http://localhost:8545
PRIVKEY=0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80
find . -type f -name 'wallets.yaml' | while read -r file; do
  echo "Processing $file ‚Ä¶"

  # extract all addresses (strips leading spaces and the "address:" prefix)
  grep -E '^[[:space:]]*address:' "$file" \
    | sed -E 's/^[[:space:]]*address:[[:space:]]*//' \
    | while read -r addr; do

      if [[ $addr =~ ^0x[0-9a-fA-F]{40}$ ]]; then
        echo "‚Üí Sending 10‚ÄØETH to $addr"
        cast send "$addr" \
          --value 10ether \
          --private-key "$PRIVKEY" \
          --rpc-url "$RPC_URL"
      else
        echo "‚ö†Ô∏è  Skipping invalid address: '$addr'" &gt;&amp;2
      fi

    done
done
</code></pre>
<h3 id="deploy-l1-contracts"><a class="header" href="#deploy-l1-contracts">Deploy L1 contracts</a></h3>
<pre><code>cd local_v1
zkstack ecosystem init --deploy-paymaster=false --deploy-erc20=false --observability=false \
  --deploy-ecosystem --l1-rpc-url=http://localhost:8545 --chain era1 --zksync-os
</code></pre>
<h3 id="start-sequencer"><a class="header" href="#start-sequencer">Start sequencer</a></h3>
<p>After this, you can finally run the sequencer:</p>
<pre><code>general_zkstack_cli_config_dir=../zkstack-playground/local_v1/chains/era1 cargo run --release
</code></pre>
<p>the <code>general_zkstack_cli_config_dir</code> config option will read the YAML files and set the proper addresses and private keys.
Alternatively, you need to set:</p>
<ul>
<li><code>l1_sender_operator_commit_pk</code> to the operator private key of <code>wallets.yaml</code> of <code>zkstack</code> tool output,</li>
<li><code>l1_sender_operator_prove_pk</code> and <code>l1_sender_operator_execute_pk</code> to respective wallets from <code>wallets.yaml</code>,</li>
<li><code>l1_sender_bridgehub_address</code> to <code>bridgehub_proxy_addr</code> in <code>contracts.yaml</code> of <code>zkstack</code> tool output</li>
<li>(if running validium) <code>l1_sender_da_input_mode</code> to <code>validium</code></li>
</ul>
<h3 id="restarting"><a class="header" href="#restarting">Restarting</a></h3>
<p>If you restart anvil, you have to repeat a subset of steps from above, to re-create the bridgehub contracts:</p>
<ul>
<li>fund the accounts (shell script)</li>
<li>re-run ecosystem init</li>
<li>you might also want to restart the sequencer - it will figure out the state on L1, and commit missing batches.</li>
</ul>
<h2 id="regenerate-l1-state"><a class="header" href="#regenerate-l1-state">Regenerate L1 state</a></h2>
<p>Note: There is an <a href="https://github.com/mm-zk/zksync_tools/tree/main/zkos/update_state_json">experimental tool</a> that can run these commands for you. If it turns out to be useful, we might make it more permanent.</p>
<p>L1 state is checked in into this repo under <code>zkos-l1-state.json</code>. To regenerate it from scratch, run the following commands:</p>
<pre><code>anvil -m "stuff slice staff easily soup parent arm payment cotton trade scatter struggle" --state zkos-l1-state.json
</code></pre>
<p>Note that we pass this mnemonic to have <code>0x36615cf349d7f6344891b1e7ca7c72883f5dc049</code> rich wallet - legacy from era.</p>
<p>Then deploy the contracts using legacy tooling (see above).
After that, add a deposit transaction to the state - integration and load tests expect that <code>0x36615cf349d7f6344891b1e7ca7c72883f5dc049</code> has L2 funds. For this, use <code>generate-deposit</code> tool in this repo.
Make sure to provide correct <code>bridgehub_addres</code> (you can find it in <code>configs/contracts.yaml</code>):</p>
<pre><code>&gt; cargo run --bin zksync_os_generate_deposit -- --bridgehub &lt;BRIDGEHUB_ADDRESS&gt;
L1 balance: 9879999865731420184000
Successfully submitted L1-&gt;L2 deposit tx with hash '0xb8544a2a9bc55713f1f94acf3711c23d07e02917f44885b05e20b13af1402283'

Process finished with exit code 0

</code></pre>
<p>Now stop anvil (ctrl+c) - the state will be saved to the file. Rerun it with <code>--load-state zkos-l1-state.json</code>  (<code>--load-state</code> - not <code>--state</code>, otherwise it will be overwritten). Commit the new file in git.</p>
<p>Update values in <code>L1SenderConfig</code>:</p>
<ul>
<li><code>bridgehub_address</code> -&gt; <code>bridgehub_proxy_addr</code> in <code>contracts.yaml</code> of <code>zkstack</code> tool output</li>
<li><code>operator_commit_pk</code> -&gt; <code>operator_private_key</code> in <code>wallets.yaml</code></li>
<li><code>operator_prove_pk</code>, <code>operator_execute_pk</code> -&gt; <code>prove_operator</code> and <code>execute_operarator</code> keys from wallets.yaml</li>
</ul>
<h2 id="running-multiple-chains"><a class="header" href="#running-multiple-chains">Running multiple chains</a></h2>
<h3 id="create-a-new-chain-era2"><a class="header" href="#create-a-new-chain-era2">Create a new chain (era2)</a></h3>
<pre><code class="language-shell">zkstack ecosystem create --ecosystem-name local-v1 --l1-network localhost --chain-name era2 --chain-id 271 --prover-mode no-proofs --wallet-creation random --link-to-code ../../zksync-era --l1-batch-commit-data-generator-mode rollup --start-containers false   --base-token-address 0x0000000000000000000000000000000000000001 --base-token-price-nominator 1 --base-token-price-denominator 1 --evm-emulator false
</code></pre>
<p>Make sure to fund the accounts again (see the script in the docs above).</p>
<p>Init new chain (deploying contacts etc):</p>
<pre><code class="language-shell">zkstack chain init --deploy-paymaster=false  \
  --l1-rpc-url=http://localhost:8545 --chain era2 \
  --server-db-url=postgres://invalid --server-db-name=invalid
</code></pre>
<p>And start the sequencer.</p>
<pre><code class="language-shell">general_zkstack_cli_config_dir=../zkstack-playground/local_v1/chains/era2 cargo run --release
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="updates"><a class="header" href="#updates">Updates</a></h1>
<h2 id="verification-keys"><a class="header" href="#verification-keys">Verification keys</a></h2>
<p>If you did any change to zkos binary (for example including a binary from the new version of zkos), you should do following steps:</p>
<ul>
<li>commit it here &amp; an inside zksync-airbender-prover (you‚Äôll be committing multiblock_batch.bin binary).</li>
<li>generate verification keys and update era-contracts
<ul>
<li>you can use the tool from https://github.com/mm-zk/zksync_tools/tree/main/zkos/generate_vk</li>
<li>you need to find the latest era-contracts tag that we used (probably on top of <a href="https://github.com/matter-labs/era-contracts/tree/zksync-os-stable">zksync-os-stable branch</a>)</li>
<li>once the script generate the change, commit it into era-contracts repo.</li>
</ul>
</li>
</ul>
<p>Then follow instructions below for era-contracts updates.</p>
<h2 id="updating-era-contracts"><a class="header" href="#updating-era-contracts">Updating era contracts</a></h2>
<p>If you do any change to era-contracts, we should update zkos-l1-state.json (especially if this is a breaking change ‚Äì be careful with those when we‚Äôre in production).</p>
<ul>
<li>commit your change to era-contracts, and generate a new release/tag (we name them as zkos-v0.29.3 for example)</li>
<li>go to zksync-era, checkout zksync-os-integration, and update the contracts dependency there (this step will hopefully disappear soon)</li>
<li>then you can run the tool from: https://github.com/mm-zk/zksync_tools/tree/main/zkos/update_state_json
<ul>
<li>this tool will generate state.json (and genesis.json if needed), and if you run it with COMMIT_CHANGES=true, it will also create a branch in zksync-os-server.</li>
</ul>
</li>
<li>check that the server is still working (start anvil with new state, and run a clear server).</li>
<li>commit your change to zksync-os-server and optionally create a new release.</li>
</ul>
<p>WARNING: instructions above assume that you didn‚Äôt change genesis hash (any change to L2Upgrade Handler, ComplexUpgrader or WrappedBasedToken might change it).
If you did, then you have to regenerate hashes, which is a longer process.</p>
<h2 id="updating-genesis"><a class="header" href="#updating-genesis">Updating genesis</a></h2>
<p>There are 3 contracts that are part of genesis ‚Äì L2ComplexUpgrader, L2GenesisUpgrade, L2WrappedBaseToken. If any of them have changed, you‚Äôll have to regenerage genesis.</p>
<p>Currently it is a little bit of a frustrating process, but we plan to improve it in near future.</p>
<ul>
<li>Step 1: run parts from updating era contracts: Run the tool above, and confirm that genesis.json was really updated.</li>
<li>Step 2: compute ‚Äúgenesis hash‚Äù - when you start the server <strong>with new genesis.json</strong> created in the step above - add a print here: https://github.com/matter-labs/zksync-os-server/blob/main/node/bin/src/batcher/util.rs#L36 to get the hash value.</li>
<li>Step 3: Put the new hash value into: https://github.com/matter-labs/zksync-era/blob/zksync-os-integration/etc/env/file_based/genesis.yaml</li>
<li>Step 4: Re-run the Step 1. Make sure to use zksync-era with the Step3, as new genesis is used inside CTM registration, so it will impact the state.json contents.</li>
<li>Step 5: check that everything works ‚Äì you should be able to run anvil with the new state (<code>anvil --load_state zkos-l1-state.json</code>) and zksync-os-server <strong>with new genesis.json</strong> (it normally loads it from local directory).</li>
</ul>
<p>https://github.com/matter-labs/zksync-os-server/blob/main/node/bin/src/batcher/util.rs#L36</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="js/version-box.js"></script>
        <script src="js/mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
